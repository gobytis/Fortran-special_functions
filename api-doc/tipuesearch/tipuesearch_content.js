var tipuesearch = {"pages":[{"title":" special_functions ","text":"special_functions Developer Info gobytis","tags":"home","loc":"index.html"},{"title":"beta – special_functions","text":"public interface beta ベータ関数です。 beta(a, b) = $int_0&#94;1 t&#94;{a-1} (1 - t)&#94;{a - 1} dt$ Contents Functions int_beta sp_beta dp_beta Functions private pure module function int_beta(a, b) result(retval) Arguments Type Intent Optional Attributes Name integer, intent(in) :: a argument 1 integer, intent(in) :: b argument 2 Return Value real(kind=dp) 戻り値 private pure module function sp_beta(a, b) result(retval) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: a argument 1 real(kind=sp), intent(in) :: b argument 2 Return Value real(kind=sp) 戻り値 private pure module function dp_beta(a, b) result(retval) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a argument 1 real(kind=dp), intent(in) :: b argument 2 Return Value real(kind=dp) 戻り値","tags":"","loc":"interface\\beta.html"},{"title":"digamma – special_functions","text":"public interface digamma ディガンマ関数用のラッパーです。 Contents Functions dp_digamma Functions private impure module function dp_digamma(x) result(retval) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x 入力 Return Value real(kind=dp) 戻り値","tags":"","loc":"interface\\digamma.html"},{"title":"trigamma – special_functions","text":"public interface trigamma トリガンマ関数用のラッパーです。 Contents Functions dp_trigamma Functions private impure module function dp_trigamma(x) result(retval) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x 入力 Return Value real(kind=dp) 戻り値","tags":"","loc":"interface\\trigamma.html"},{"title":"polygamma – special_functions","text":"public interface polygamma ポリガンマ関数です。 Contents Functions dp_polygamma Functions private impure recursive module function dp_polygamma(k, x) result(retval) Arguments Type Intent Optional Attributes Name integer, intent(in) :: k 関数パラメータ\nk = 0, 1, 2, corresponds to digamma, trigamma, tetragamma.... respectively. real(kind=dp), intent(in) :: x 入力 Return Value real(kind=dp) 戻り値","tags":"","loc":"interface\\polygamma.html"},{"title":"special_functions – special_functions","text":"特殊関数を格納するクラスです。 Uses iso_fortran_env Used by Descendants: beta_function polygamma_function Contents Interfaces beta digamma trigamma polygamma Interfaces public        interface beta ベータ関数です。 beta(a, b) = $int_0&#94;1 t&#94;{a-1} (1 - t)&#94;{a - 1} dt$ private pure module function int_beta(a, b) result(retval) Arguments Type Intent Optional Attributes Name integer, intent(in) :: a argument 1 integer, intent(in) :: b argument 2 Return Value real(kind=dp) 戻り値 private pure module function sp_beta(a, b) result(retval) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: a argument 1 real(kind=sp), intent(in) :: b argument 2 Return Value real(kind=sp) 戻り値 private pure module function dp_beta(a, b) result(retval) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a argument 1 real(kind=dp), intent(in) :: b argument 2 Return Value real(kind=dp) 戻り値 public        interface digamma ディガンマ関数用のラッパーです。 private impure module function dp_digamma(x) result(retval) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x 入力 Return Value real(kind=dp) 戻り値 public        interface trigamma トリガンマ関数用のラッパーです。 private impure module function dp_trigamma(x) result(retval) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x 入力 Return Value real(kind=dp) 戻り値 public        interface polygamma ポリガンマ関数です。 private impure recursive module function dp_polygamma(k, x) result(retval) Arguments Type Intent Optional Attributes Name integer, intent(in) :: k 関数パラメータ\nk = 0, 1, 2, corresponds to digamma, trigamma, tetragamma.... respectively. real(kind=dp), intent(in) :: x 入力 Return Value real(kind=dp) 戻り値","tags":"","loc":"module\\special_functions.html"},{"title":"beta_function – special_functions","text":"ベータ関数の実装です。 Uses Ancestors: special_functions Contents None","tags":"","loc":"module\\beta_function.html"},{"title":"polygamma_function – special_functions","text":"ポリガンマ関数の実装です。\nThis is a modern fortran implementation of a following algorithm.\n[Reference]\n石岡恒憲 (1993) ポリ・ガンマ関数の C 言語，および Fortran 77 言語による算譜.\n    応用統計学, 22(1), 23--37.\n    Ishioka T. (1993) Plygamma functions subroutine programmed in C and Fortran 77 Uses ieee_arithmetic Ancestors: special_functions Contents None","tags":"","loc":"module\\polygamma_function.html"},{"title":"special_functions.f90 – special_functions","text":"Contents Modules special_functions Source Code special_functions.f90 Source Code !> 特殊関数を格納するクラスです。 module special_functions use , intrinsic :: iso_fortran_env implicit none private ! 変数の kind integer , parameter :: sp = real32 integer , parameter :: dp = real64 ! public 関数一覧 public :: beta public :: digamma , trigamma , polygamma !> ベータ関数です。 !> `beta(a, b)` = $int_0&#94;1 t&#94;{a-1} (1 - t)&#94;{a - 1} dt$ interface beta pure module function int_beta ( a , b ) result ( retval ) !> argument 1 integer , intent ( in ) :: a !> argument 2 integer , intent ( in ) :: b !> 戻り値 real ( dp ) :: retval end function pure module function sp_beta ( a , b ) result ( retval ) !> argument 1 real ( sp ), intent ( in ) :: a !> argument 2 real ( sp ), intent ( in ) :: b !> 戻り値 real ( sp ) :: retval end function pure module function dp_beta ( a , b ) result ( retval ) !> argument 1 real ( dp ), intent ( in ) :: a !> argument 2 real ( dp ), intent ( in ) :: b !> 戻り値 real ( dp ) :: retval end function end interface !> ディガンマ関数用のラッパーです。 interface digamma impure module function dp_digamma ( x ) result ( retval ) !> 入力 real ( dp ), intent ( in ) :: x !> 戻り値 real ( dp ) :: retval end function end interface !> トリガンマ関数用のラッパーです。 interface trigamma impure module function dp_trigamma ( x ) result ( retval ) !> 入力 real ( dp ), intent ( in ) :: x !> 戻り値 real ( dp ) :: retval end function end interface !> ポリガンマ関数です。 interface polygamma impure recursive module function dp_polygamma ( k , x ) result ( retval ) !> 関数パラメータ !> k = 0, 1, 2, corresponds to digamma, trigamma, tetragamma.... respectively. integer , intent ( in ) :: k !> 入力 real ( dp ), intent ( in ) :: x !> 戻り値 real ( dp ) :: retval end function end interface end module","tags":"","loc":"sourcefile\\special_functions.f90.html"},{"title":"beta_function.f90 – special_functions","text":"Contents Submodules beta_function Source Code beta_function.f90 Source Code !> ベータ関数の実装です。 submodule ( special_functions ) beta_function implicit none contains !> 整数に対する beta 関数の値を返します。 !> `beta(a, b)` = $int_0&#94;1 t&#94;{a-1} (1 - t)&#94;{a - 1} dt$ pure module function int_beta ( a , b ) result ( retval ) !> argument 1 integer , intent ( in ) :: a !> argument 2 integer , intent ( in ) :: b !> 戻り値 real ( dp ) :: retval real ( dp ) :: dp_a real ( dp ) :: dp_b dp_a = dble ( a ) dp_b = dble ( b ) retval = exp ( log_gamma ( dp_a ) + log_gamma ( dp_b ) - log_gamma ( dp_a + dp_b )) end function !> 単精度実数に対する beta 関数の値を返します。 !> `beta(a, b)` = $int_0&#94;1 t&#94;{a-1} (1 - t)&#94;{a - 1} dt$ pure module function sp_beta ( a , b ) result ( retval ) !> argument 1 real ( sp ), intent ( in ) :: a !> argument 2 real ( sp ), intent ( in ) :: b !> 戻り値 real ( sp ) :: retval retval = exp ( log_gamma ( a ) + log_gamma ( b ) - log_gamma ( a + b )) end function !> 倍精度実数に対する beta 関数の値を返します。 !> `beta(a, b)` = $int_0&#94;1 t&#94;{a-1} (1 - t)&#94;{a - 1} dt$ pure module function dp_beta ( a , b ) result ( retval ) !> argument 1 real ( dp ), intent ( in ) :: a !> argument 2 real ( dp ), intent ( in ) :: b !> 戻り値 real ( dp ) :: retval retval = exp ( log_gamma ( a ) + log_gamma ( b ) - log_gamma ( a + b )) end function end submodule","tags":"","loc":"sourcefile\\beta_function.f90.html"},{"title":"polygamma_function.f90 – special_functions","text":"Contents Submodules polygamma_function Source Code polygamma_function.f90 Source Code !> ポリガンマ関数の実装です。 !> This is a modern fortran implementation of a following algorithm. !> [Reference] !> 石岡恒憲 (1993) ポリ・ガンマ関数の C 言語，および Fortran 77 言語による算譜. !>     応用統計学, 22(1), 23--37. !>     Ishioka T. (1993) Plygamma functions subroutine programmed in C and Fortran 77 !> submodule ( special_functions ) polygamma_function use , intrinsic :: ieee_arithmetic implicit none integer , parameter :: i_bernoulli_trm = 10 real ( dp ), parameter :: bernoulli_number ( i_bernoulli_trm ) = [ & 1.6666666666666666d-1 , 3.3333333333333333d-2 , & 2.3809523809523809d-2 , 3.3333333333333333d-2 , & 7.5757575757575757d-2 , 2.5311355311355311d-1 , & 1.6666666666666667d0 , 7.0921568627450980d0 , & 5.4971177944862155d1 , 5.2912424242424242d2 & ] contains !> ディガンマ関数用のラッパーです。 impure module function dp_digamma ( x ) result ( retval ) !> 入力 real ( dp ), intent ( in ) :: x !> 戻り値 real ( dp ) :: retval integer , parameter :: k = 0 retval = dp_polygamma ( k , x ) end function !> トリガンマ関数用のラッパーです。 impure module function dp_trigamma ( x ) result ( retval ) !> 入力 real ( dp ), intent ( in ) :: x !> 戻り値 real ( dp ) :: retval integer , parameter :: k = 1 retval = dp_polygamma ( k , x ) end function !> ディガンマ関数の値 (psi&#94;k(x)) を返します。 impure recursive module function dp_polygamma ( k , x ) result ( retval ) !> 関数パラメータ !> k = 0, 1, 2, corresponds to digamma, trigamma, tetragamma.... respectively. integer , intent ( in ) :: k !> 入力 real ( dp ), intent ( in ) :: x !> 戻り値 real ( dp ) :: retval if ( k < 0 . or . x < 0.0_dp ) then retval = ieee_value ( 0.0_dp , ieee_quiet_nan ) return end if if ( x == 0.0_dp ) then retval = ieee_value ( 0.0_dp , ieee_positive_inf ) return end if block real ( dp ) :: large_number real ( dp ) :: k_fractorial large_number = get_large_number ( k ) k_fractorial = gamma ( dble ( k + 1 )) if ( x >= large_number ) then retval = get_polygamma_for_large_x ( k , x ) else retval = get_polygamma_for_small_x ( k , x , large_number ) end if end block end function impure module function get_large_number ( k ) result ( large_number ) integer , intent ( in ) :: k real ( dp ) :: large_number real ( dp ), parameter :: default_value = 1 3.06_dp real ( dp ), parameter :: power = 1.0_dp / 1 8.0_dp real ( dp ), parameter :: f_coeff = 17461 1.0_dp / 5 5.0_dp real ( dp ), parameter :: large_number_coeff = 6.81921_dp if ( k < 0 ) then large_number = ieee_value ( 0.0_dp , ieee_quiet_nan ) return end if if ( k <= 3 ) then large_number = default_value return end if block real ( dp ) :: f integer :: i do i = 21 , ( k + 9 ) f = f * dble ( i ) end do do i = 3 , ( k + 1 ) f = f / dble ( i ) end do f = f * f_coeff large_number = large_number_coeff * f ** power if ( large_number < default_value ) then large_number = default_value end if end block end function impure module function get_polygamma_for_large_x ( k , x ) result ( retval ) integer , intent ( in ) :: k real ( dp ), intent ( in ) :: x real ( dp ) :: retval integer :: i if ( k == 0 ) then retval = dp_digamma_for_large_x ( x ) else retval = dp_high_order_polygamma_for_large_x ( k , x ) end if end function impure module function get_polygamma_for_small_x ( k , x , large_value ) result ( polygamma ) integer , intent ( in ) :: k real ( dp ), intent ( in ) :: x real ( dp ), intent ( in ) :: large_value real ( dp ) :: polygamma real ( dp ) :: y real ( dp ) :: y_powered integer :: isgn integer :: n integer :: i n = int ( large_value - x ) y = dble ( n ) + x + 1.0_dp if ( x < 0.0 . and . y == dble ( int ( y ))) then polygamma = ieee_value ( 0.0_dp , ieee_positive_inf ) return end if polygamma = dp_polygamma ( k , y ) if ( mod ( k , 2 ) == 0 ) then isgn = - 1 else isgn = 1 end if block real ( dp ) :: k_fractorial k_fractorial = gamma ( dble ( k + 1 )) do i = 1 , n + 1 y = y - 1.0_dp if ( abs ( y ) < 1.0d-3 ) then if ( x > 0.0d0 ) then y = x - dble ( int ( x + 0.5 )) else y = x - dble ( int ( x - 0.5 )) end if end if y_powered = y ** k if ( y_powered * y == 0.0d0 ) then polygamma = ieee_value ( 0.0_dp , ieee_negative_inf ) return end if polygamma = polygamma + dble ( isgn ) * k_fractorial / y_powered / y end do end block end function pure module function dp_digamma_for_large_x ( x ) result ( digamma ) real ( dp ), intent ( in ) :: x real ( dp ) :: digamma real ( dp ) :: x_squared integer :: isgn integer :: ii integer :: i2 integer :: i x_squared = x * x digamma = 0.0_dp isgn = 1 do i = 1 , i_bernoulli_trm ii = i_bernoulli_trm - i + 1 i2 = ii + ii digamma = digamma + bernoulli_number ( ii ) / dble ( i2 * isgn ) digamma = digamma / x_squared isgn = - isgn end do digamma = digamma + log ( x ) - 0.5_dp / x end function pure module function dp_high_order_polygamma_for_large_x ( k , x ) result ( polygamma ) integer , intent ( in ) :: k real ( dp ), intent ( in ) :: x real ( dp ) :: polygamma real ( dp ) :: c real ( dp ) :: x_squared integer :: isgn integer :: i , j x_squared = x * x polygamma = 0.0_dp c = 1.0_dp if ( mod ( k , 2 ) == 0 ) then isgn = 1 else isgn = - 1 end if block integer :: ii integer :: i2 do i = 1 , i_bernoulli_trm ii = i_bernoulli_trm - i + 1 i2 = ii + ii do j = i2 + 1 , i2 + k - 1 c = c * dble ( j ) end do polygamma = polygamma + bernoulli_number ( ii ) * c * dble ( isgn ) polygamma = polygamma / x_squared isgn = - isgn end do end block do i = 1 , k polygamma = polygamma / x end do block real ( dp ) :: x_powered real ( dp ) :: k_fractorial x_powered = x ** k k_fractorial = gamma ( dble ( k + 1 )) polygamma = polygamma - 0.5_dp * k_fractorial / x_powered / x * dble ( isgn ) c = gamma ( dble ( k )) polygamma = polygamma - c / x_powered * dble ( isgn ) end block end function end submodule","tags":"","loc":"sourcefile\\polygamma_function.f90.html"}]}